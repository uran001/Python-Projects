THE HOT POTATO CLASSIC GAME

    In this game children line up in a circle and pass an item from neighbor to neighbor as fast as they can.
    At a certain point in the game, the action is stopped and the child who has the item (the potato)
    is removed from the circle. Play continues until only one child (i.e., the winner) is left.
    
    We will implement a general simulation of the Hot Potato game:
    Our program will input a list of names and a constant, call it “num,” to be used for counting.
    It will return the name of the last person remaining after repetitive counting by num.
    What happens at that point is up to you :)
    
    To simulate the circle, we will use a queue.
    Assume that the child holding the potato will be at the front of the queue.
    Upon passing the potato, the simulation will simply dequeue and then immediately enqueue that child,
    putting her at the end of the line. She will then wait until all the others have been at the front before it will
    be her turn again. After num dequeue/enqueue operations, the child at the front will be removed permanently
    (i.e., eliminated from the game) and
    another cycle will begin. This process will continue until only one name remains (i.e., the size of the queue is 1).


THE "SPICY" HOT POTATO GAME:
    
    This time, we "spice up" the hot potato simulator by introducing (i) lives and (ii) some randomness.
    
    Like in common videogames, in this new version of the hot potato game players have "lives",
    so the list of players is actually a list of list (or a matrix)
    in which each player  has a name and a number of lives: e.g., ("[Marco", 7], ["Hoang", 5], ["Alice", 9])
    
    When a round of the game ends, the loser should lose one "life". If the loser has only one life left,
    then they should be eliminated. However, we also introduce "randomness" in the game...
    
    Randomness: players do not loose a life (or get eliminated) with certainty at the end of each round.
    Once a loser is determined at the end of one round, there is a 50% chance that the loser will keep their life, and a 50% chance
    that they will lose it. To simulate the 50% you can check the value of the random number generated by the
    Python internal function random(), which returns a random floating point between 0 and 1 (see import statement)
    
    ex.:
    
    if random() > 0.5:
        # do something (e.g. keep the life)
    else:
        # do something else (e.g. lose life or get eliminated)
        
ADDITIONAL FILES
    
    Basic example of an adapter class to provide a stack interface to Python's list.
    FIFO queue implementation using a Python list as underlying storage.
 